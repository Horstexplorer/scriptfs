#summary Documentation for the operations.h file

= operations.h =



== Functions ==

void init_resources()
  *Initialize resources used to communicate with the remote website.*
void free_resources()
  *Free all resources used by the program.*
int test_shell(PTest test, const char * file)
  *Test if a file is a shell script.*
int test_true(PTest test, const char * file)
  *Test function that always returns 1.*
int test_false(PTest test, const char * file)
  *Test function that always returns 0.*
int test_executable(PTest test, const char * file)
  *Test if a file is executable.*
int test_shell_executable(PTest test, const char * file)
  *Test is the file would be executable in a shell.*
int test_pattern(PTest test, const char * file)
  *Test a file by matching its full name against a regular expression.*
int test_program(PTest test, const char * file)
  *Test function that checks the return value of the program.*
int program_shell(PProgram program, const char * file, int fd)
  *Execute a script with the help of an interpretor.*
int program_external(PProgram program, const char * file, int fd)
  *Execute an external program and write its output on given file.*
 * get_script(const  * procs, const char * file)
  *Find the script associated with a file.*
void call_program(const char * file, const char ** args)
  *Detect if a file is a shell script or a classic executable and executes it.*
int execute_program(const char * file, const char ** args, int out, const char * path_in)
  *Spawn a process that executes an external program.*

== Detailed Description ==


=====================================================================================

Filename: operations.h

Description: Different operations on script files

Version: 1.0 Created: 08/05/2012 15:12:30 Revision: none Compiler: gcc

Author: Fran√ßois Hissel Company:

=====================================================================================

== Function Documentation ==

{{{
#void init_resources   (
  )
}}}
  Initialize resources used to communicate with the remote website.
  This function initializes some resources. It should be called at the start of the program, before any use of the external program.

*Returns*:
  And a return value!

{{{
#void free_resources   (
  )
}}}
  Free all resources used by the program.
  This function releases all the resources allocated by the program, to allow for a normal and clean exit. It frees the memory and closes the files.

*Returns*:
  And a return value!

{{{
#int test_shell   (
  PTest test,
  const char * file  )
}}}
  Test if a file is a shell script.
  This function is one possible implementation of a TestFunction function. This one is used when the script interpretor is the shell. It tests if a particular file is a script by looking at the two first bytes and checking if they are a shebang. 

1 if the file is a shell script, 0 otherwise

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#int test_true   (
  PTest test,
  const char * file  )
}}}
  Test function that always returns 1.
  This function returns 1 without checking anything on the actual file. It can be used as a script TestFunction function so that every file is interpretated as a script and read by an external program. 

Always 1

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#int test_false   (
  PTest test,
  const char * file  )
}}}
  Test function that always returns 0.
  This function returns 0 without checking anything on the actual file. It can be used as a script TestFunction function so that no file is interpretated as a script. 

Always 0

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#int test_executable   (
  PTest test,
  const char * file  )
}}}
  Test if a file is executable.
  This function is one possible implementation of a TestFunction function. It tests if the file in argument has the executable attribute in the mirror file system. 

1 if the file is executable, 0 otherwise

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#int test_shell_executable   (
  PTest test,
  const char * file  )
}}}
  Test is the file would be executable in a shell.
  This function checks if the file would be executable in a shell, that is either it is a shell script or it is an executable file. Thus the result of this function is the binary-or of test_shell and test_executable. 

1 if the file is executable in a shell, 0 otherwise

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#int test_pattern   (
  PTest test,
  const char * file  )
}}}
  Test a file by matching its full name against a regular expression.
  This function is one possible implementation of a TestFunction function. It matches the name of the file in argument with the regular expression hold by the test variable. A regular expression is a standard POSIX basic regular expression. It accepts characters like ., *, ?, +,... See also the man page of grep for more details about basic regular expressions. 

1 if the file matches the regular expression, 0 otherwise

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#int test_program   (
  PTest test,
  const char * file  )
}}}
  Test function that checks the return value of the program.
  This test function only checks the return value of the underlying program. If this value is not 0 (which means an error occurred), the file is not considered as a good script. 

1 if the file may be regarded as a script, 0 otherwise

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#int program_shell   (
  PProgram program,
  const char * file,
  int fd  )
}}}
  Execute a script with the help of an interpretor.
  This function of the ProgramFunction type executes a script as it would be done by a shell. It is assumed the file (script) starts with a shebang #!, then the path of the interpretor is written on the same first line. This interpretor is used to execute the script. The function spawns a new process that loads the interpretor. The standard output is redirected to the file which descriptor is given. 

Error code of the external program after its execution

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#int program_external   (
  PProgram program,
  const char * file,
  int fd  )
}}}
  Execute an external program and write its output on given file.
  This function is a simple wrapper of the execute_program function and publishes it as a ProgramFunction type. It executes the external program on the specified file and redirects its output on the file which descriptor is given. 

Error code of the external program after its execution

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
# * get_script   (
  const  * procs,
  const char * file  )
}}}
  Find the script associated with a file.
  This function tests the file in argument and tells if it is a script. It goes through all the procedures in the list given as argument, in the order in which they are stored. As soon as a test succeeds, the file is recognized as a script and a pointer to the corresponding procedure is returned. If no matching procedure is found, the function returns a null pointer. Since it is called very often (each time a folder is explored and a file is opened), it should be very fast and not rely too much on external programs. 

Pointer to a procedure which test function succeeds when applied to the file, null if no procedure is found

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#void call_program   (
  const char * file,
  const char ** args  )
}}}
  Detect if a file is a shell script or a classic executable and executes it.
  The function checks if the file in the first argument is a shell script or a classic executable file. It then executes it according to its nature. The executed program replaces the current process and nothing is done with input and output file descriptors which should be redirected before the call to the function if needed. Since the current process is replaced by a new one, the function should never return. The mere fact that it returns tells that an error occured.

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#int execute_program   (
  const char * file,
  const char ** args,
  int out,
  const char * path_in  )
}}}
  Spawn a process that executes an external program.
  This function creates a new process which will execute the external program located at file. The third argument is a file descriptor on which the output will be written. If the descriptor is null, no output will be written at all. The last argument is a full path to a file which content should be provided on the standard input of the external program. If nothing has to be sent to the external program, the user should give a null value to this parameter. 

Error code of the program after the end of its execution

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

---
|| [sfs Main Page] || [sfs_files Files] ||
